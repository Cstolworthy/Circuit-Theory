<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 3: Logic Gates | Circuit Theory & Robotics</title>
    <link rel="stylesheet" href="../css/styles.css">
    <script src="../js/script.js" defer></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>Circuit Theory & Robotics</h1>
            <p class="tagline">A comprehensive guide to understanding circuits and building robots</p>
        </div>
    </header>

    <main class="container">
        <div class="lesson-nav">
            <a href="../index.html">← Back to Course Overview</a>
        </div>

        <article class="lesson-content">
            <h2>Lesson 3: Logic Gates</h2>
            
            <section>
                <h3>Introduction</h3>
                <p>Logic gates are the fundamental building blocks of digital circuits. They implement boolean functions, taking binary inputs (0 or 1) and producing binary outputs according to specific rules. Understanding logic gates is essential for designing and analyzing digital circuits, from simple LED controls to complex microprocessors in robotic systems.</p>
                <p>In this lesson, we'll explore the basic types of logic gates, their truth tables, symbols, and how they can be combined to create more complex digital functions.</p>
            </section>
            
            <section>
                <h3>Basic Logic Gates</h3>
                
                <h4>1. NOT Gate (Inverter)</h4>
                <p>The NOT gate, also called an inverter, has a single input and produces the opposite (complement) of that input.</p>
                <div class="code-block">
                    Symbol: A -->|>o--> Y (where Y = NOT A or Ā)
                    
                    Truth Table:
                    A | Y
                    -----
                    0 | 1
                    1 | 0
                </div>
                <p>The NOT gate reverses the logic state - if the input is TRUE (1), the output is FALSE (0), and vice versa.</p>
                
                <h4>2. AND Gate</h4>
                <p>The AND gate produces a high output (1) only when all of its inputs are high.</p>
                <div class="code-block">
                    Symbol: A -->\
                            &  )--> Y (where Y = A AND B)
                           B -->/
                    
                    Truth Table:
                    A | B | Y
                    ---------
                    0 | 0 | 0
                    0 | 1 | 0
                    1 | 0 | 0
                    1 | 1 | 1
                </div>
                <p>The AND gate implements logical multiplication: the output is 1 only if both input A AND input B are 1.</p>
                
                <h4>3. OR Gate</h4>
                <p>The OR gate produces a high output (1) when at least one of its inputs is high.</p>
                <div class="code-block">
                    Symbol: A -->\
                            ≥1 )--> Y (where Y = A OR B)
                           B -->/
                    
                    Truth Table:
                    A | B | Y
                    ---------
                    0 | 0 | 0
                    0 | 1 | 1
                    1 | 0 | 1
                    1 | 1 | 1
                </div>
                <p>The OR gate implements logical addition: the output is 1 if either input A OR input B (or both) are 1.</p>
                
                <h4>4. NAND Gate</h4>
                <p>The NAND gate is an AND gate followed by a NOT gate. Its output is the complement of an AND gate.</p>
                <div class="code-block">
                    Symbol: A -->\
                            &  )o--> Y (where Y = NOT(A AND B))
                           B -->/
                    
                    Truth Table:
                    A | B | Y
                    ---------
                    0 | 0 | 1
                    0 | 1 | 1
                    1 | 0 | 1
                    1 | 1 | 0
                </div>
                <p>The NAND gate is particularly important because it is "functionally complete" - any boolean function can be implemented using only NAND gates.</p>
                
                <h4>5. NOR Gate</h4>
                <p>The NOR gate is an OR gate followed by a NOT gate. Its output is the complement of an OR gate.</p>
                <div class="code-block">
                    Symbol: A -->\
                            ≥1 )o--> Y (where Y = NOT(A OR B))
                           B -->/
                    
                    Truth Table:
                    A | B | Y
                    ---------
                    0 | 0 | 1
                    0 | 1 | 0
                    1 | 0 | 0
                    1 | 1 | 0
                </div>
                <p>Like the NAND gate, the NOR gate is also functionally complete - any boolean function can be implemented using only NOR gates.</p>
                
                <h4>6. XOR Gate (Exclusive OR)</h4>
                <p>The XOR (Exclusive OR) gate produces a high output when an odd number of its inputs are high.</p>
                <div class="code-block">
                    Symbol: A -->\
                            =1 )--> Y (where Y = A XOR B)
                           B -->/
                    
                    Truth Table:
                    A | B | Y
                    ---------
                    0 | 0 | 0
                    0 | 1 | 1
                    1 | 0 | 1
                    1 | 1 | 0
                </div>
                <p>The XOR gate outputs 1 when the inputs are different, and 0 when they are the same. It's commonly used in arithmetic circuits.</p>
                
                <h4>7. XNOR Gate (Exclusive NOR)</h4>
                <p>The XNOR gate is an XOR gate followed by a NOT gate. Its output is the complement of an XOR gate.</p>
                <div class="code-block">
                    Symbol: A -->\
                            =1 )o--> Y (where Y = NOT(A XOR B))
                           B -->/
                    
                    Truth Table:
                    A | B | Y
                    ---------
                    0 | 0 | 1
                    0 | 1 | 0
                    1 | 0 | 0
                    1 | 1 | 1
                </div>
                <p>The XNOR gate outputs 1 when the inputs are the same, and 0 when they are different. It's essentially an "equality detector".</p>
                
                <div class="note-box">
                    <strong>Note on Symbols:</strong> The ASCII representations above are simplified. In actual circuit diagrams, standardized symbols are used which vary slightly between American (ANSI/IEEE) and European (IEC) standards.
                </div>
            </section>
            
            <section>
                <h3>Logic Gates in Electronic Circuits</h3>
                <p>In physical electronic circuits, logic gates are implemented using transistors. For example:</p>
                <ul>
                    <li>A basic NOT gate can be constructed using a single transistor</li>
                    <li>An AND gate typically requires two transistors</li>
                    <li>More complex gates require more transistors</li>
                </ul>
                <p>In modern integrated circuits (ICs), logic gates are available in standardized packages, such as:</p>
                <ul>
                    <li>74xx series (TTL - Transistor-Transistor Logic)</li>
                    <li>40xx series (CMOS - Complementary Metal-Oxide-Semiconductor)</li>
                </ul>
                <p>For example, a 7408 IC contains four 2-input AND gates, while a 7432 contains four 2-input OR gates.</p>
            </section>
            
            <section>
                <h3>Boolean Algebra and Logic Gate Equivalents</h3>
                <p>Boolean algebra provides a mathematical foundation for working with logic gates. Some key identities include:</p>
                <ul>
                    <li>Double negation: NOT(NOT A) = A</li>
                    <li>Commutative laws: A AND B = B AND A; A OR B = B OR A</li>
                    <li>Associative laws: (A AND B) AND C = A AND (B AND C); (A OR B) OR C = A OR (B OR C)</li>
                    <li>Distributive laws: A AND (B OR C) = (A AND B) OR (A AND C); A OR (B AND C) = (A OR B) AND (A OR C)</li>
                    <li>De Morgan's laws: NOT(A AND B) = NOT A OR NOT B; NOT(A OR B) = NOT A AND NOT B</li>
                </ul>
                <p>These laws allow us to simplify complex logic expressions and design more efficient circuits.</p>
                
                <h4>Implementing Gates Using NAND or NOR</h4>
                <p>Since NAND and NOR gates are functionally complete, we can implement any other gate using just one of these:</p>
                <div class="code-block">
                    Using only NAND gates:
                    NOT A = A NAND A
                    A AND B = (A NAND B) NAND (A NAND B)
                    A OR B = (A NAND A) NAND (B NAND B)
                    
                    Using only NOR gates:
                    NOT A = A NOR A
                    A OR B = (A NOR B) NOR (A NOR B)
                    A AND B = (A NOR A) NOR (B NOR B)
                </div>
                <p>This property is particularly useful in integrated circuit design, where using a single type of gate can simplify manufacturing.</p>
            </section>
            
            <section>
                <h3>Combining Logic Gates</h3>
                <p>By combining multiple logic gates, we can create more complex functions. Let's look at some examples:</p>
                
                <h4>1. Half Adder</h4>
                <p>A half adder adds two bits and produces a sum (S) and a carry (C):</p>
                <div class="code-block">
                    S = A XOR B  (sum bit)
                    C = A AND B  (carry bit)
                </div>
                <p>This circuit requires an XOR gate and an AND gate.</p>
                
                <h4>2. Full Adder</h4>
                <p>A full adder adds three bits (two inputs and a carry-in) and produces a sum (S) and a carry-out (Cout):</p>
                <div class="code-block">
                    S = A XOR B XOR Cin
                    Cout = (A AND B) OR (Cin AND (A XOR B))
                </div>
                <p>This circuit can be built using two half adders and an OR gate.</p>
                
                <h4>3. Multiplexer (MUX)</h4>
                <p>A multiplexer selects one of several input signals and forwards it to a single output line:</p>
                <div class="code-block">
                    2-to-1 MUX:
                    Y = (A AND NOT S) OR (B AND S)
                    
                    Where S is the select signal, A and B are inputs, and Y is the output.
                </div>
                <p>Multiplexers are fundamental components in many digital systems, allowing for data routing and selection.</p>
            </section>
            
            <section>
                <h3>Logic Gates in Microcontrollers</h3>
                <p>In microcontroller programming for robotics, we often use bitwise operations to implement logic functions:</p>
                <div class="code-block">
                    // C/C++ code examples
                    
                    // AND operation (e.g., checking if a specific bit is set)
                    if (sensorValue & 0x01) {  // Check if bit 0 is set
                        // Bit is set (1)
                    }
                    
                    // OR operation (e.g., setting a specific bit)
                    PORTB |= 0x20;  // Set bit 5 to 1
                    
                    // NOT operation (e.g., toggling bits)
                    PORTC = ~PORTC;  // Toggle all bits
                    
                    // XOR operation (e.g., toggling a specific bit)
                    PORTD ^= 0x10;  // Toggle bit 4
                </div>
                <p>These operations allow us to efficiently control hardware components and process sensor data in robotic applications.</p>
            </section>
            
            <section>
                <h3>Practical Applications in Robotics</h3>
                <p>Logic gates and their combinations have numerous applications in robotics:</p>
                <ul>
                    <li><strong>Sensor Processing:</strong> Using AND gates to verify multiple conditions, OR gates for alternative conditions</li>
                    <li><strong>Motor Control:</strong> Using combinations of gates to implement H-bridge logic for bidirectional motor control</li>
                    <li><strong>Decision Making:</strong> Implementing simple if-then logic without a microcontroller</li>
                    <li><strong>Input Debouncing:</strong> Using flip-flops (combinations of gates) to clean up noisy button inputs</li>
                    <li><strong>Encoding/Decoding:</strong> Using gates to encode sensor states or decode commands</li>
                </ul>
                <p>For example, a simple obstacle-avoiding robot might use logic gates to implement the rule: "If left sensor OR right sensor detects an obstacle, then change direction."</p>
            </section>
            
            <section>
                <h3>Practice Exercises</h3>
                <ol>
                    <li>Draw the truth table for the expression (A AND B) OR (NOT C)</li>
                    <li>Simplify the expression NOT(A AND B) OR (A AND NOT B) using Boolean algebra</li>
                    <li>Design a circuit using only NAND gates that implements an XOR function</li>
                    <li>Create a logic circuit that outputs 1 when exactly two of its three inputs are 1</li>
                    <li>Implement a 1-bit comparator that outputs:
                        <ul>
                            <li>G = 1 when A > B</li>
                            <li>E = 1 when A = B</li>
                            <li>L = 1 when A < B</li>
                        </ul>
                        Where A and B are 1-bit inputs.
                    </li>
                </ol>
                <p>Solutions will be provided in the next lesson.</p>
            </section>
            
            <section>
                <h3>Solutions to Lesson 2 Exercises</h3>
                <ol>
                    <li>
                        <strong>Add the binary numbers 1101 and 1011</strong><br>
                        1101 + 1011 = 11000 (24 in decimal)
                    </li>
                    <li>
                        <strong>Subtract 1010 from 11001 using direct method and two's complement</strong><br>
                        Direct method: 11001 - 1010 = 1111<br>
                        Two's complement: 11001 + two's complement of 1010<br>
                        Two's complement of 1010 = 0101 + 1 = 0110<br>
                        11001 + 0110 = 1111
                    </li>
                    <li>
                        <strong>Multiply 1101 by 101</strong><br>
                        1101 × 101 = 1101 × (100 + 1) = 110100 + 1101 = 1000001 (65 in decimal)
                    </li>
                    <li>
                        <strong>Perform bitwise AND, OR, and XOR on 1100 and 1010</strong><br>
                        1100 & 1010 = 1000 (AND)<br>
                        1100 | 1010 = 1110 (OR)<br>
                        1100 ^ 1010 = 0110 (XOR)
                    </li>
                    <li>
                        <strong>Shift 10110 left by 2 positions and right by 1 position</strong><br>
                        10110 << 2 = 1011000 (left shift)<br>
                        10110 >> 1 = 1011 (right shift)
                    </li>
                </ol>
            </section>
            
            <section>
                <h3>Summary</h3>
                <p>In this lesson, we've covered:</p>
                <ul>
                    <li>The basic types of logic gates (NOT, AND, OR, NAND, NOR, XOR, XNOR) and their truth tables</li>
                    <li>How logic gates are implemented in electronic circuits</li>
                    <li>Boolean algebra principles for working with logic expressions</li>
                    <li>How to implement any gate using only NAND or NOR gates</li>
                    <li>Creating more complex circuits by combining logic gates</li>
                    <li>Applications of logic gates in microcontroller programming and robotics</li>
                </ul>
                <p>Understanding logic gates provides the foundation for designing and analyzing digital circuits. In the next lesson, we'll explore various circuit components beyond logic gates, including resistors, capacitors, and transistors, which are essential for building practical electronic circuits for robotics.</p>
            </section>
        </article>

        <div class="lesson-navigation">
            <a href="lesson2.html" class="prev-next-button">← Previous: Binary Arithmetic</a>
            <a href="lesson4.html" class="prev-next-button">Next: Circuit Components →</a>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 Circuit Theory & Robotics. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>
